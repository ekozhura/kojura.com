---
layout: post.hbt
title: "Композиция в SuperCollider. Часть 1. Потоки"
alias: supercollider-score-language-part-1
date: 2014-07-13 09:04:59 +0200
collection: posts
author: Evgeny Kozhura
header_image: gifs/alien.002.gif
---
Основой алгоритмической композиции, по сути, являются математические методы генерации партитур. Синтаксические конструкции или библиотеки функций и классов, которые используются в композиции, часто выделяются в так называемый score language, то есть язык, который используется для определения партитур. Score language в SuperCollider базируется на потоках (абстрактный класс Stream), событиях (класс Event) и паттернах (абстрактный класс Pattern). Сперва рассмотрим потоки.

<!--more-->

Термины **итератор**, **генератор** и **поток** в разных языках программирования используются для описания похожих концепций и абстракций, но не всегда аналогичных. В общем случае, итератор - это объект, который осуществляет последовательный доступ к элементам коллекции. Это несколько отличается от перебора элементов коллекции по их индексам.

Интерфейс итератора предполагает следующее поведение. Во-первых, необходимо инициализировать итератор с каким-то начальным состоянием и сбрасывать состояние итератора на начальное. Начальное состояние чаще всего предполагает, что итератор вернет первый элемент коллекции. Во-вторых, необходимо извлекать следующий элемент коллекции. И наконец, если коллекция имеет конечное число элементов, необходимо каким-то образом узнать, что были перебраны все элементы.

Генератор - это специальная функция, которая сохраняет внутреннее состояние и способна приостановить свое выполнение. Когда функция будет вызвана в следующий раз, то она продолжит выполнение на том месте, где остановилась, вместо того чтобы отработать заново. Это достигается вызовом специального оператора `yield`, который возвращает значение (аналогично оператору `return`) и приостанавливает функцию до ее следующего вызова.

Пример генератора на Python:

```python
def counter(n):
    while True:
        yield n
        n += 1
```

В примере реализован счетчик, который сгенерирует новое значение каждый раз, когда будет вызван. Поскольку в цикле отсутствует условие выхода из цикла, счетчик по сути генерирует бесконечную последовательность целых чисел.

```python
>>> f = counter(2)
>>> f.next()
2
>>> f.next()
3
>>> f.next()
4
```

Как видно из примера, поведение генератора аналогично итератору.

Ну и наконец, потоки (данных) - своего рода "ленивые" списки (lazy lists). Это означает, что элементы коллекции вычисляются "по требованию", всякий раз при попытке доступа к ним. Собственно, потоки - это абстракция, структура данных с определенными свойствами. Реализуются они с помощью итераторов и генераторов. Так как элементы вычисляются тогда, когда к ним пытаются получить доступ, потоки могут быть бесконечными (как в примере счетчика).

В SuperCollider потоки определяются набором классов, которые наследуются от абстрактного класса `Stream`. Каждый поток реализует метод `next`, позволяющий получать последовательный доступ к элементам в потоке. Интересно то, что для абстрактного класса `Object` так же определен метод `next` (который возвращает `this`), а поскольку в SuperCollider все классы наследуются от `Object`, то любой объект по сути может быть рассмотрен как поток. Метод `reset`, если он реализован, сбрасывает состояние потока на начальное или просто возвращает `nil`.

Наиболее полезными классами-потомками `Stream` являются `FuncStream` и `Routine`. `FuncStream` позволяет нам использовать функции при вызове методов `next` и `reset`.

UPD: Наверное, это не совсем точно. С одной стороны, действительно всё может быть потоком, с другой стороны, здесь под потоком понимаются разные сущности. В одном случае мы говорим о потоке, как о структуре данных, о некой последовательности значений. В другом случае, когда мы говорим о классе Stream, то имеем ввиду скорее интерфейс, который обобщает разные типы данных, среди которых есть и потоки, и простые числа, и функции. Таким образом, все что наследуется от `Object`, обладает методами интерфейса `Stream`, но в узком смысле потоком, как структурой данных не является.

UPD: Получается, что многие объекты, имея свойства потоков, потоками не являются. Зачем такие сложности? Ну это дает определенные выгоды. Во-первых, это предоставляет единый интерфейс для итерирования. Рассматривая объекты как потоки, мы можем обрабатывать их единообразно, компоновать и трансформировать данные одним алгоритмом.

В следующем примере мы определяем функцию как аргумент конструктора, которая будет выполняться всякий раз, когда мы вызываем метод `next`. И всякий раз эта функция будет возвращать число, выбранное из заданного списка случайным образом. Тем самым, с помощью экземпляра класса `FuncStream`, мы можем определить бесконечный поток, состоящий из случайных чисел.

```javascript
(
a = FuncStream.new({ #[1, 2, 3, 4].choose });
5.do({ a.next.postln; });
)
```

Функция для метода `reset` не определена, а потому вызвав `reset`, мы получим `nil`.

Класс `Routine` также позволяет запускать функцию для определения значений в потоке данных, но особенность `Routine` в том, что объекты этого класса являются генераторами. То есть, с помощью `yield` мы сохраняем текущее состояние и приостанавливаем выполнение функции до следующего вызова метода `next`. Исчерпав все вызовы `yield`, в конечном итоге функция вернет `nil`. Простейшие примеры:

```javascript
(
a = Routine.new({ 1.yield; 2.yield; });
a.next.postln;  // 1
a.next.postln;  // 2
a.next.postln;  // nil
)
```

```javascript
(
a = Routine.new({
        3.do({ arg i; i.yield; })
    });
b.nextN(4);//  выведет -> [ 0, 1, 2, nil ]
)
```

К потоку можно применять математические операции, его можно отфильтровать или применять функции к каждому элементу.

Метод `collect` - аналогичен функции map в функциональных языках программирования, а именно над каждым элементом выполняется какое-то действие, в результате мы получаем новый, уже трансформированный поток. В данном примере, к числам от 0 до 9 будет прибавлено 100:

```javascript
(
a = Routine.new({
        10.do({ arg i; i.yield; })
    });
b = a.collect({ arg item; item + 100 ; });
b.nextN(10);
)
```

Методы `select` и `reject` позволяют создать новый поток из элементов текущего, если эти элементы удовлетворяют условию (в случае `select`) или не удовлетворяют условию (в случае `reject`). Например, необходимо отобрать все нечетные числа из последовательности:

```javascript
(
a = Routine.new({
        10.do({ arg i; i.yield; })
    });

// функция, определенная в select будет возвращать true для всех нечетных чисел
b = a.select({ arg item; item.odd; });
b.nextN(5);
)
```

Аналогичную функцию, но с использованием `reject` можно переписать таким образом:

```javascript
(
a = Routine.new({
        10.do({ arg i; i.yield; })
    });

// функция, определенная в reject будет возвращать false для всех четных чисел
b = a.reject({ arg item; item.even; });
b.nextN(5);
)
```

---
Вот, собственно, и вся базовая информация об итераторах, потоках и их реализации в SuperCollider. В следующих постах я рассмотрю события и паттерны в SuperCollider. В общем, продолжение следует.