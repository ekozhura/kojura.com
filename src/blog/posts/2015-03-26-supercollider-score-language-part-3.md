---
layout: post.hbt
author: Evgeny Kozhura
title: "Композиция в SuperCollider. Часть 3. Время и планировщики задач."
alias: supercollider-score-language-part-3
date: 2015-03-24 00:04:21 +0200
collection: posts
header_image: gifs/blade.runner.002.gif
---

Эта статья - небольшое отступление от темы Score Language в SuperCollider. Но безусловно необходимое для дальнейшего продвижения по теме событий и паттернов. Речь пойдет о планировщиках задач и о работе со временем в SuperCollider.

В предыдущих статьях я рассмотрел потоки данных и способы их генерации с помощью `Routine`, `FuncStream`, и паттернов. Особенно интересен класс `Routine`, который с помощью `yield` может приостанавливать свое выполнение, возвращать значение и при повторном вызове продолжать выполнение с места остановки.

У `Routine` есть еще одна интересная особенность - мы можем явно указать задержку по времени, после которой процедура восстановит выполнение. Для этого, вместо `next`, мы посылаем объекту `Routine` сообщение `play`. Время задержки будет определяться числовым значением, которое вернет `yield`. В этом примере итерация цикла выполняется через каждые полсекунды:

``` js
(
c = Routine {
    100.do {
        |i|
        ("Current value : " + i).postln;
        0.5.yield;
    };
};
)

c.play; // старт

c.stop; // в любой момент можно остановить проигрывание.
```

В данном случае `Routine` выполняет совершенно другую задачу, не связанную с генерацией значений. Возможно, чтобы подчеркнуть, что значение, которое возвращает `yield` - это именно время задержки, для классов `Float` и `Integer` определен специальный метод `wait`, который по сути является псевдонимом `yield` [^1]. Тот же пример, но с методом `wait`, нагляднее демонстрирует поведение функции в `Routine`. Теперь код выглядит так, как будто на каждой итерации мы не значение возвращаем, а делаем паузу на полсекунды.

``` js
(
c = Routine {
    100.do {
        |i|
        ("Current value : " + i).postln;
        0.5.wait;
    };
};
)
```

Таким образом, с помощью `Routine` можно написать простой планировщик задач [^2]. Определим функцию, которая принимает в качестве аргументов время задержки (параметр `delta`) и функцию, которую необходимо выполнять всякий раз по прошествию заданного времени `delta`:

```js
(
w = {
    arg delta = 0.5, func = {};
    var sched = Routine {
        inf.do {
            func.value();
            delta.wait;
        }
    };
    sched.play;
};
)
// функция w вернет ссылку на объект sched
z = w.value(2, { "event occured".postln; });

z.stop;
```

Именно так работает метод `sched` в семействе классов `Clock`, и используется он как раз для этих целей - выполнение задач в какой-то момент в будущем [^3]. И именно его использует `Routine` в ответ на сообщение `play`, поэтому предыдущий пример можно переписать так:

```js
// остановить выполнение можно с помощью cmd + .
SystemClock.sched(0, { "event occured!".postln; 2; });
```

Как видно из примера, если функция возвращает числовое значение, `SystemClock.sched` будет повторять выполнение этой функции снова и снова, а временем задержки будет возвращаемое функцией числовое значение. В данном случае, время задержки 2 секунды.

Абстрактный класс `Clock` и его потомки - `SystemClock`, `AppClock` и `TempoClock` предназначены для отсчета времени, как на то намекают их названия. У каждого конкретного класса свое назначение. `SystemClock` и `AppClock` всегда отсчитывают время в секундах и не могут быть инстанциированы. У `AppClock` более низкий системный приоритет, поэтому он используется там, где точность времени не критична - например для работы с GUI. `TempoClock` предоставляет такой же точный тайминг, как и `SystemClock`, но возвращает не секунды, а количество ударов в секунду (beats per second). Плюс, в отличии от других классов, можно инстанциировать сколько угодно экземляров `TempoClock`, при этом при старте SuperCollider по умолчанию создается один экземпляр и он становится доступен по `TempoClock.default`.

Идея в том, что каждый отсчет времени в `SystemClock` и `AppClock` - это постоянная величина, ведь секунда есть секунда. Поэтому особого смысла инстанциировать несколько экземпляров каждого из этих классов нет. А с `TempoClock` все иначе, beats per second - величина относительная, и если меняется темп, то меняется и интервал между двумя отсчетами. Разные счетчики позволяют выполнять запланированные функции с разной частотой:

```
(
c = TempoClock(1);
d = TempoClock(0.5); // темп в два раза медленнее

c.sched(0, { |b| ["Beats from c:", b].postln; 1 });
d.sched(0, { |b| ["Beats from d:", b].postln; 1 });
)
```

Итак, вернемся к `Routine` и рассмотрим, как работает метод `play`. Метод `play` определен для базового класса `Stream` и доступен для всех его потомков, не только для `Routine`. Его поведение следующее - если при вызове метода в качестве аргумента был передан экземпляр класса `Clock` (или его подклассов), то этому объекту посылается сообщение `play`. В противном случае, это сообщение посылается дефолтному счетчику, который возвращает `TempoClock.default`.

``` js
/* метод play класса Stream */
/* File: supercollider/SCClassLibrary/Common/Streams/Stream.sc */
play { arg clock, quant;
    clock = clock ? TempoClock.default;
    clock.play(this, quant.asQuant);
}
```

Сам же метод `play` в классе `Clock` - это обертка метода `sched`, поэтому код `SystemClock.play({ "event occured!".postln; 2; })` будет аналогичен `SystemClock.sched(0, { "event occured!".postln; 2; });`

Остановить задачу можно с помощью метода `stop`. Этот метод останавливает выполнение функции внутри `Routine`, как если бы она достигла конца. После этого любая попытка возобновить выполнение (к примеру с помощью методов `next` или `value`) ни к чему не приведет. Можно лишь заново начать выполнение `Routine` с помощью метода `reset`.

Вот такое поведение не всегда желательно. Если необходимо поставить на паузу задачу, то `Routine` для этих целей не подойдет - `yield` (или `wait`) внутри `Routine` всегда будет возвращать одно и то же значение в качестве времени задержки. Не говоря о том, что сама по себе пауза означает задержку, не определенную по времени - 5 секунд, 10 минут, 2 часа.

Тут на помощь приходит `PauseStream` и его два важных подкласса `EventStreamPlayer` и `Task`. `EventStreamPlayer` имеет смысл рассмотреть в отдельной статье вместе с событиями и с потоками событий. Что касается `Task`, то он во многом повторяет поведение `Routine` (по существу, это обертка вокруг `Routine`, поэтому методы `yield` и `wait` будут работать внутри `Task`), в то же время наследует у `PauseStream` способность ставать на паузу и восстанавливать выполнение.

``` js
(
d = Routine {
    50.do({ arg i;
        i.squared.postln;
        0.5.wait;
    });
}
)
```

Функция, определенная в `Routine`, может передана в `Task` без изменений. Но поведение методов `play`, и `stop` отличается от соответствующих методов в `Routine`.

``` js
(
t = Task {
    50.do({ arg i;
        i.squared.postln;
        0.5.wait;
    });
}
)
// весь набор для управления выполнением задачи
t.play
t.pause     // аналогичен stop
t.resume    // аналогичен play
t.stop
t.reset
```

`Task` не является стопроцентной заменой `Routine`, в нем иногда обнаруживается довольно странное поведение, о чем предупреждает хелп файл по классу. К тому же, `Routine` наследует свое поведение не только от `Stream`, но и от `Thread`. А `Task` по-прежнему остается подклассом `Stream`, интерфейс которого расширяется с помощью `PauseStream` [^4].

---

В следующей статье я обязательно рассмотрю такое важное понятие в SuperCollider как Событие (`Event`). `Event` в SuperCollider обозначает именно музыкальное событие (например, проигрывание ноты), поэтому имеет к композиции самое непосредственное отношение. Но в тоже время объекты этого класса применяются и для (неожиданно) прототипирования классов в SuperCollider. А поскольку я параллельно пишу статьи по ООП в SuperCollider, то буквально разрываюсь, с какой стороны подойти к теме ивентов. Но как бы там ни было, следующая статья по SuperCollider должна быть посвящена классу `Event`.

[^1]: Строго говоря, метод `wait` просто вызывает `yield`, соответственно все правила для `yield` будут справедливы и для `wait`. Например, вызвав `wait` в какой-нибудь функции вне `Routine` мы получим стандартное исключение _"yield was called outside of a Routine"_.

[^2]: В зависимости от контекста, *Планировщик* может соответствовать одному из двух шаблонов - Scheduler или Scheduled Task. Между ними есть разница, несмотря на созвучные названия. В статье речь идет именно о Scheduled Task. Подробнее о шаблоне: http://c2.com/cgi/wiki?ScheduledTask.

[^3]: Аналогичное поведение функции `at` в Overtone.

[^4]: Вообще, если придираться к словам, то оба родительских класса `PauseStream` и `Thread` классов `Task` и `Routine`, наследуются от общего предка `Stream`. И каждый по своему расширяет интерфейс `Stream` уникальным поведением. Но если `PauseStream` - это все еще `Stream`, то семантика `Thread` никакого отношения к потокам не имеет и наследуется от `Stream` чисто формально, чтобы передать некоторые его свойства классу `Routine`. Все-таки, множественного наследования в SuperCollider нет, а композицией делу поможешь.