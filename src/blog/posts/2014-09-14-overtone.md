---
layout: post.hbt
title: "Обзор Overtone"
alias: overtone
date: 2014-09-14 20:39:51 +0300
collection: posts
author: Evgeny Kozhura
header_image: gifs/alien.003.gif
---
Диалекты Lisp достаточно популярны в качестве языков для синтеза и алгоритмической композиции (особенно, для алгоритмической композиции). На их основе за последние десятилетия было созданно внушительное количество DSL (предметно-специфических языков) - Nyquist, PatchWork (и его современная ипостась PWGL), OpenMusic, Common Music, Impromptu и прочие. Эти DSL относятся к разряду внутренних, "встраиваемых" языков, которые реализуются поверх базового языка (в данном случае Lisp), используют его синтаксические средства и среду выполнения, и одновременно расширяют его функциональность.

Для этой задачи Lisp отлично подходит, так как обладает широкими возможностями для метапрограммирования. Так, с помощью макросов можно определять новые языковые конструкции, чего не так просто добиться, используя обычные функции. Более того, изначально сферой применения Lisp была разработка искуственного интеллекта, что в общем-то делает его привлекательным для композиторов, практикующих алгоритмическую композицию.

Итак, Overtone - это тоже DSL, он тоже базируется на диалекте Lisp (Clojure, в данном случае). В отличии от Nyquist или Common Lisp Music (не путать с Common Music), Overtone не обладает собственным аудио движком, а использует SuperCollider, таким образом, по сути являясь фронтедом (клиентом) к scsynth. Так как Overtone встроен в Clojure, то в качестве рантайма используется (естественно) JVM, что открывает огромные возможности для создания мультимедийных приложений. Вы не ограничены только лишь взаимодействием с scsynth, в своем проекте вы можете использовать любые необходимые вам Java-библиотеки, помимо собственно Clojure-библиотек.

Рассматривать Overtone как альтернативу самому языку SuperCollider не стоит. Но вполне как альтернативу другим лисповым клиентам. А среди них, к примеру, [rsc3](http://rd.slavepianos.org/?t=rsc3) - имплементация для Scheme, или клиент, позволяющий использовать Impromptu совместно со scsynth (http://impromptu.moso.com.au/libs.html). Или как альтернативу клиентам на JVM-языках, таким как [ScalaCollider](http://www.sciss.de/scalaCollider/) и [JCollider](http://www.sciss.de/jcollider/). И, естественно, Overtone будет интересен людям, у которых есть или опыт работы с Clojure или желание пописать на Clojure.

Ovetone примечателен тем, что "породил" несколько библиотек, причем некоторые из них в принципе можно использовать в проектах, никак не связанных ни с Overtone, ни с аудио синтезом и алгоритмической композицией в целом. В первую очередь, это библиотеки, являющиеся основой событийной модели Overtone: `at-at` (планировщик задач) и `handlers` - набор абстракций для синхронных и асинхронных обработчиков событий. Для мультимедийных проектов можно использовать `osc-clj` - это библиотека для работы с протоколом OSC 1.0.

Собственно, основной недостаток Overtone кроется в реализации поверх JVM. JVM имеет ряд негативных ньюансов, когда дело касатся аккуратного и точного тайминга и вообще работы с сигналами (не важно, аудио или управляющий сигнал) в реальном времени. В принципе, в Overtone эти проблемы частично решаемы, вплоть до замещения в JVM дефолтного сборщика мусора альтернативными реализациями.

Итак, что собой представляет работа с Overtone. Все предельно просто. С помощью Lein вы вытягиваете все необходимые проекту зависимости (overtone в данном случае), запускаете REPL и устанавливаете соединение с scsynth. Более подробно процесс установки и первого запуска описан в wiki проекта.

Теперь давайте попробуем написать что-то осмысленное. У нас в арсенале несколько макросов, один из них `defsynth` - аналог `SynthDef` в SuperCollider. Напишем определение синта в REPL:

```clojure
(defsynth beep
  [freq 440 amp 0.5]
  (out 0
    (* amp (sin-osc freq))))
```

Макрос defsynth создаст для нас функцию beep, которая принимает в качестве аргументов параметры freq (частота) и amp (амплитуда). Выполним ее:

```clojure
(beep 880 0.5)
```

"Потушить" звук можно с помощью команды `kill`:

```clojure
(kill beep)
```

В Overtone внушительный список юнит-генераторов - он если и не полностью соответствует списку генераторов в SuperCollider, то очень близок к нему. Так что ваши синты, реализованные на SuperCollider можно легко транслировать на Clojure. У меня была, однако, проблема с битовыми юнит-генераторами, я или недоглядел документацию или они действительно не поддерживаются Overtone.

Продолжим. Практически аналогичным макросу `defsynth` является макрос `definst`:

```clojure
(definst beep
  [freq 440 amp 0.5]
    (* amp (sin-osc freq)))
```

`definst` определяет инструмент (в отличии от `defsynth`, который определяет синтезатор в том смысле, как это принятно в терминологии SuperCollider). Инструмент - это абстракция, так сказать, расширенный вариант synth, который облегчает проектирование и использование синтезаторов в Overtone. У нее есть свои особенности и отличия от synth. Нет необходимости указывать юнит-генератор out в своем инструменте - в инструменте реализован "внутренний" микшер, который и контролирует вывод аудиосигналов. Но такая реализация накладывает ограничение на количество выходных каналов - инструмент может звучать только в моно или в стерео. С помощью шин внутри инструмента, есть возможность управлять параметрами инструмента и цеплять к инструменту эффекты.

```clojure
;; начало воспроизведения
(beep 880 0.7)
;; добавим ревербератор в цепочку эффектов
;; что в принципе бессмысленно в таком простом инструменте
(inst-fx! beep fx-reverb)
;; снизим уровень громкости
(inst-volume! beep 0.3)
;; наконец, остановим воспроизведение:
(kill beep)
```

В Overtone есть целый ряд готовых к употреблению инструментов. Это, помимо упомянутых эффектов, несколько сэмплеров и синтезаторов. Для старта, когда нет желания углубляться в саунд дизайн, и для экспериментов с библиотекой - вполне достаточно. Кстати, одна из забавных фич Overtone - это его интеграция с Freesound. Overtone позволяет подгружать необходимые семплы из сервиса и использовать в проекте - по такому принципу реализовано sampled-piano.

Я упоминал библиотеку `at-at`, которая является частью Overtone, но может быть использована вообще в любом проекте, в котором может потребоваться планировщик задач. Использовать ее безумно просто:

```clojure
(at (+ 2000 (now)) (beep 880 0.8))
```

В качестве аргументов функция `at` принимает точное время, когда нужно выполнить функцию, и саму функцию - в данном случае через 2 секунды после выполнения этого кода наш инструмент начнет воспроизведение.

В Overtone предусмотрено несколько модулей-хелперов для работы с нотами, ритмом, тональностями, интервалами, аккордами и т.д. - не слишком впечатляющая коллекция, но очевидно облегчает работу во время живых выступлений. Что еще есть в Overtone и как это использовать - можно понять, изучая код проекта на [github](https://github.com/overtone/overtone). Код отлично документирован и организован. Обсуждения проектов, консультации, общение происходят почтовой рассылке https://groups.google.com/forum/#!forum/overtone

Чего нет в Overtone, так это чего-то отдаленно напоминающего прокси в SuperCollider. Также нет библиотеки паттернов, но с этим проблем быть вообще не должно - в Clojure собрать свой генератор списков достаточно просто. Нет обширного сообщества, вносящего обширный вклад в развитие проекта. Но так как проект молодой и все еще развивается - это дело времени.

---
Итак, в качестве эпилога. Overtone - впечатляющая библиотека, местами урезанная в возможностях по сравнению с библиотекой классов из SuperCollider, зато легко расширяемая благодаря платформе JVM. Это полноценный фронтенд к scsynth, с огромным набором юнит генераторов, с уникальными фичами вроде интеграции с Freesound или представлением синта в виде графа. Так как Overtone все еще активно разрабатывается, проектов на нем не слишком много. Среди них - [Leipzig](https://github.com/ctford/leipzig) (композиторская библиотека), [MiniBeast](https://github.com/overtone/mini-beast#mini-beast) (эмулятор аналогового синтезатора).

В следующих постах постараюсь уделить внимание другим лисповым DSL.