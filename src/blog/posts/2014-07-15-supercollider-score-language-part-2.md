---
layout: post.hbt
title: "Композиция в SuperCollider. Часть 2. Введение в паттерны"
alias: supercollider-score-language-part-2
date: 2014-07-22 23:23:03 +0200
collection: posts
author: Evgeny Kozhura
header_image: gifs/alien.001.gif
---
В прошлой статье я рассмотрел потоки в SuperCollider и базовые возможности по их генерации. Между тем, в SuperCollider существуют более продвинутые способы определения потоков. Речь о паттернах и об их преимуществах.

Паттерны - это классы, которые наследуются от базового класса Pattern и реализуют методы `asStream` и `embedInStream`. Для удобства названия классов-паттернов начинаются с прописной "P" (`Pbind`, `Pseries`, `Pfunc`, и т.д.).

Паттерны в SuperCollider выполняют роль спецификаций, они описывают правила, согласно которым создаются потоки. При этом, они не порождают потоки (например, вызов `next` вернет ссылку на сам объект паттерна, как это определено в унаследованном методе `next` класса `Object`). Чтобы создать поток, необходимо вызвать метод `asStream` объекта паттерна, который вернет экземпляр одного из подклассов `Stream`.

Библиотека паттернов - это некоторое множество алгоритмов, которые мы можем использовать для создания потоков. Нет необходимости каждый раз писать свои генераторы для классов `Routine` и `FuncStream`. Существует вероятность того, что необходимый алгоритм уже реализован в одном из паттерн-классов.

К примеру, попробуем реализовать простейший счетчик с помощью `Routine`:

```javascript
(
var step = 2;
a = Routine({
    | inc = 0 |
    loop {
        inc.yield;
        inc = inc + step;
    }
});

10.do({ a.next(2).postln; });
)
```

Аналогичную последовательность мы получим, если реализуем счетчик с помощью паттернов:

```javascript
(
d = Pseries(2, 2, inf).asStream;
10.do({
    d.next.postln;
});
)
```

В общем случае, `Pseries` генерирует арифметическую прогрессию и принимает в качестве параметров начальное значение, разность между членами прогрессии и длину прогреcсии.

Очевидны некоторые преимущества использования паттернов - запись более лаконична, код менее подвержен ошибкам, в действии - принцип повторного использования кода. Еще одним преимуществом паттернов в SuperCollider является их вложенность. Достигается это благодаря методу `embedInStream` который позволяет "встраивать" в поток любой объект (числа, строки, символы, коллекции и т.д.).

Попробую проиллюстрировать работу `embedInStream` таким примером. Скажем, внутри одного объекта `Routine` мы определяем еще один объект `Routine`. Первый, routeIn генерирует последовательность чисел 0, 1, 2, 3, 4, а  второй, routeOut - 200, 201, ..., 209. Задача в том, чтобы включить значения внутреннего потока routeIn во внешний routeOut таким образом, чтобы при последовательном обходе элементов routeOut с помощью `next` мы имели доступ к обеим последовательностям как к единому целому. Сделать это можно таким способом:

```javascript
(
var routeOut = Routine.new({
    var count = nil,
    routeIn = Routine.new({
        5.do{
            arg i; i.yield;
        };
    });

    {count = routeIn.next; count.notNil}.while ({
        count.yield;
    });

    10.do{
        arg i; (i+200).yield;
    }
});

{(m = routeOut.next).notNil}.while{
    m.postln;
};
)
```

То есть, сначала мы создаем внутренний `Routine`, генерирующий последовательность [0, 1, 2, 3, 4]. Затем обходим эти элементы в цикле while и вызываем оператор `yield` для каждого элемента. Потом вызываем `yield` для элементов [200, 201, ..., 209]. Таким образом, во внешнем `Routine` обе последовательности объединяются в один поток, по которому мы двигаемся с помощью `routeOut.next`.

Метод `embedInStream` делает то же самое - встраивает объект в поток. Перепишем код:

```javascript
(
var routeOut = Routine.new({
    var routeIn = Routine.new({
        5.do {
            arg i; i.yield;
        };
    }).embedInStream;

    10.do {
        arg i; (i+200).yield;
    }
});

{(m = routeOut.next).notNil}.while {
    m.postln;
};
)
```

Единственный момент, который следует учесть, используя `embedInStream`. Поскольку внутри `embedInStream` вызывается оператор `yield`, то вызов `embedInStream` необходимо помещать в `Routine`, иначе будет сгенерировано исключение.

Теперь перепишем этот пример таким образом, чтобы вместо объектов `Routine`` использовать паттерны:

```javascript
(
a = Pseq([
        Pseries(0, 1, 5),
        Pseries(200, 1, 10)
    ]).asStream;

{(m = a.next).notNil}.while{
    m.postln;
};
)
```

`Pseq` позволяет создать поток на основе заданого списка значений. В качестве параметров, помимо самого списка, принимает также число повторений списка в результирующем потоке. Когда мы вызываем метод `asStream` экземпляра класса `Pseq`, создается объект `Routine`, внутри которого вызывается метод `embedInStream`. Поведение этого метода для `Pseq` определено следующим образом - внутри цикла последовательно извлекается каждый элемент списка. В нашем случае каждый такой элемент - это экземляр класса `Pseries`. В этом же цикле управление переходит к методу `embedInStream`, определенному уже для `Pseries`. Таким образом, элементы, генерируемые объектами `Pseries`, встраиваются во внешний поток, который создается объектом класса `Pseq`.

---
Итого. Паттерны позволяют инкапсулировать реализацию разнообразных генераторов потоков (получаются своего рода обертки каких-то подклассов класса `Stream`, а в большинстве случаев это будет `Routine`). Они также поддерживают вложенность и кое-какие операции трансформации (аналогичные тем, что были рассмотрены в статье о потоках), что позволяет создавать сложные паттерны из более простых. И последнее, потоки предоставляют пользователю простой и удобный API для работы с потоками. В следующей статье будет уделено больше внимания классам паттернов и операциям над ними.